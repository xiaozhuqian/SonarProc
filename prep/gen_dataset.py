'''
Generate raw waterfall and navigation data from .mat file.
Specialized for EdgeTech 4125i model, which is dual frequency: 600 kHz/20; 1600 kHz/21.

Input:
    *.mat file generated by jsf2mat.m
Output: 
    raw backscatter data: *_frequency-bs.npy, shape: (ping count, sample count);
    survey line geographical coordinates: *_frequency-geo_coords.npy, shape: (ping count, 4), [[port_longitude, port_latitude, starboard_longitude, starboard_latitude], ...] in degree
    towfish attitudes: *_frequency-attitudes.npy, shape (ping count, 6), [[port_heading, port_pitch, port_roll, starboard_heading, starboard_pitch, starboard_roll], ...] in degree
    vessel nmeas: *_frequency-nmeas.npy, shape (ping count, 4), [[port_speed, port_course, starboard_speed, starboard_course], ...] speed in knot, course in degree

    downsampled backscatter data: *_frequency-bs.npy, shape: (ping count, downsampled sample count);
    tvg enhanced downsampled backscatter image: *_frequency-bs.png, shape: (ping count, downsampled sample count).

Note: range should be the same in one input file.
'''


import argparse
import os
import scipy.io as io
import numpy as np
import cv2
import logging
import sys
sys.path.append('.')
import utils.logger as logger
from utils.vis import gray_enhancing_tvg, linearStretch
from mat2npy import extract_from_mat
from prep.preprocessing import down_sample
from utils.util import absoption


def parse_args():
    parser = argparse.ArgumentParser(description='gen_image')
    parser.add_argument('--input_dir', default='./outputs/mat/', help='directory of input file')
    parser.add_argument('--out_dir', default='./outputs/npy/', help='dierctory to save backscatter and navigation data')
    
    parser.add_argument('--frequency', default=20, type=int, help='frequency code, high frequency (1600 kHz)=21, low frequency (600 kHz) = 20')
    parser.add_argument('--range', default=80., type=float, help='range of port or starboard')
    parser.add_argument('--geo_resolution', default=0.1, type=float, help='downsamplinged waterfall resolution')

    parser.add_argument('--temperature', default=26., type=float, help='sea water temperature')
    parser.add_argument('--salinity', default=28., type=float, help='sea water salinity')
    parser.add_argument('--depth', default=5., type=float, help='towfish depth')
    parser.add_argument('--pH', default=8., type=float, help='sea water pH')
    parser.add_argument('--lambd', default=20., type=float, help='tvg log factor')
    parser.add_argument('--ratio', default=0.02, type=float, help='gray linear strech clip ratio')

    args = parser.parse_args()
    return args

def main(args):

    input_names = []
    for filepath, dirnames, filenames in os.walk(args.input_dir):
        for filename in filenames:
            input_names.append(filename)
    
    for idx, input_name in enumerate(input_names):
        input_path = os.path.join(args.input_dir, input_name)
        index = input_name.split('.')[-2]
        mat = io.loadmat(input_path)

        sonardata, geo_coords, attitudes, nmeas, remain_acoustics, error_ping_number \
            =extract_from_mat(mat, args.frequency)
        
        sonardata_downsample, _, _, _ = down_sample(sonardata, geo_coords, attitudes, nmeas, \
                                                    args.range, args.geo_resolution)  # downsample backscatter data to reduce computing load
        
        # tvg enhancement
        if args.frequency == 20:
            frequency = 600
        if args.frequency == 21:
            frequency = 1600
        a = absoption(frequency*1000., args.temperature, args.salinity, args.depth, args.pH) # sound absoption in seawater, db/m
        sonardata_tvg = gray_enhancing_tvg(sonardata_downsample, args.range, args.lambd, a)
        img = linearStretch(sonardata_tvg, 1, 255, args.ratio)

        logging.info(f'{idx+1}th file/total {len(input_names)} files, {input_name}, shape_raw: {sonardata.shape}, shape_downsample: {sonardata_downsample.shape}, remains: {remain_acoustics}, error_ping: {error_ping_number}') 
        
        np.save(os.path.join(args.out_dir, 'raw', index+'_'+str(args.frequency)+'-bs'+'.npy'), sonardata) 
        np.save(os.path.join(args.out_dir, 'raw', index+'_'+str(args.frequency)+'-geo_coords'+'.npy'), geo_coords)
        np.save(os.path.join(args.out_dir, 'raw', index+'_'+str(args.frequency)+'-attitudes'+'.npy'), attitudes)
        np.save(os.path.join(args.out_dir, 'raw', index+'_'+str(args.frequency)+'-nmeas'+'.npy'), nmeas)

        np.save(os.path.join(args.out_dir, 'downsample', index+'_'+str(args.frequency)+'-bs'+'.npy'), sonardata_downsample)
        cv2.imwrite(os.path.join(args.out_dir, 'downsample', index+'_'+str(args.frequency)+'-bs'+'.png'), img)

if __name__ == '__main__':
    import time
    args = parse_args()

    if not os.path.exists(os.path.join(args.out_dir, 'raw')):
        os.makedirs(os.path.join(args.out_dir, 'raw'))
    if not os.path.exists(os.path.join(args.out_dir, 'downsample')):
        os.makedirs(os.path.join(args.out_dir, 'downsample')) 

    now = int(round(time.time()*1000))
    now02 = time.strftime('%Y-%m-%d-%H%M%S',time.localtime(now/1000))
    logger.setlogger(os.path.join(args.out_dir, f'{now02}-npy_extraction.log'))  # set logger
    for k, v in args.__dict__.items():  # save args
        logging.info("{}: {}".format(k, v))
    
    main(args)
